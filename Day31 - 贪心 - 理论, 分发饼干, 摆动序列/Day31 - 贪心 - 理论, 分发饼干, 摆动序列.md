# Day31 - 贪心 - 理论, 分发饼干, 摆动序列

## 理论基础

- 什么时候使用贪心的最好判断方法，就是Toy Example + 尝试举反例，核心思想是每一步的局部最优能找出全局最优。

## 1.✅****455.分发饼干「[讲解](https://programmercarl.com/0455.%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2.html#%E6%80%9D%E8%B7%AF)」**

- 大饼干优先喂饱大孩子 or 小饼干优先喂饱小孩子。注意数组需要排序。

## 2.✅****376. 摆动序列「[讲解](https://programmercarl.com/0376.%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97.html#%E6%80%9D%E8%B7%AF-1-%E8%B4%AA%E5%BF%83%E8%A7%A3%E6%B3%95)」**

- 一开始没想明白什么意思，过于去思考一些反例，但其实还没明白题目的意思。应该在纸上画一画，数一数。
- 看讲解：
    - 本题的贪心在于：整体摆动 == 局部不要有单调 == 去挑选原序列中的局部极大和局部极小。假设挑选的某个点不是极值点，那么其在最终序列中若作为极值点，其在原序列中最近邻的极值点肯定可以平替作为极值点。
    - 具体写法中，要注意摆动/单调增减/平台(前后单调/前后不同)几种情况。
        - 我设计使用pre和cur记录上一次摆动和当前的变化(↘️-1，➡️0，↗️1)。cur==0的话不去改动pre的值，这样可以保证平台前后单调和平台前后反转可以区分出来。因为平台前后单调，虽然趋势有变 1 → 0 → 1，但并没有增加摆动子序列的点数。
        - 小bug注意：一开始处我为了省事，让第一个点直接cnt + 1，但没考虑到[1,1,1,1]一开始便有值相同的情况。还是要多试试/想象testcase。
- 子序列问题肯定也可以用dp解，学到dp时再看。

## 3.✅****53. 最大子序和「[讲解](https://programmercarl.com/0053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.html#%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95)」**

- 看着还是像直接用dp的题目，直接dp了，因为只需要考虑前一个位置为结尾的最大和，所以只需要两个变量，还要存一个max。
- dp[i] = dp[i] if dp[i - 1] < 0 else dp[i - 1] + dp[i]
- 看讲解：
    - 这里的贪心在：只要碰到负数，就不可能存在于子序列和内（除非全是负数，最后会剩下最小的负数）所以只要把每个连续和一直为正数的子序列加起来就可以了。思路和dp是一样的。
- 题目还要求分治，感觉这里不如直接dp，分治写出来会很混乱。