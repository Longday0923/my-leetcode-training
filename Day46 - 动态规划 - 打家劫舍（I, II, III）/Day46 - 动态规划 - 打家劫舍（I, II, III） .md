#Day46 - 动态规划 - 打家劫舍（I, II, III） 

## 1.✅**198.打家劫舍「[讲解](https://programmercarl.com/0198.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)」**

- 1维dp，dp代表到第i家的时候最大收益
    - 递推公式：dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])
    - 可以转化为滚动数组降维，python平行赋值只需要两个变量：a, b = b, max(b, a + nums[i])
    - 初始化：数组最短只有一个，可以a, b = 0, nums[0]
    - 遍历：for i in range(1, len(nums))

## 2.✅**213.打家劫舍II「[讲解](https://programmercarl.com/0213.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII.html)」**

- Initial Idea:
    - 一开始一直在想，是否可以设置flag，标记当前最大和是否带了第一个，不太好写；
    - 是否能把数组首尾相接，直接一个式子解决所有问题。多次尝试好像没有很好的办法。
    - 想到首位相邻的话，只能有你没我，所以直接分两种情况讨论。一开始也是担心这个遍历两遍会不会导致浪费时间。但是这样写是最简单的。
    - 最终就是这样实现，第一遍是有头没尾的上一题，第二遍是无头有尾的上一题。取max。
    - 担心的一点是，有没有可能两边都没有取头尾：确实可能，不过这时候的数值应该相等。

## 3.✅**337.打家劫舍 III「[讲解](https://programmercarl.com/0337.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)」**

- 树型打家劫舍，还是要模仿前面打家劫舍使用的动态规划的思路：到达某个节点时，分不使用这个节点的和，和使用这个节点的和的max。
- 确定树的遍历顺序：因为相当于收集整棵树的所有节点的某种和，所以使用后序遍历。
- 返回值：和数组型的打家劫舍类似，需要返回到当前节点的最大和，同时因为下一步计算时，若取当前节点，还需要其子节点的子节点的最大值，所以需要多返回一个子节点的最大值的和。
- 打家劫舍的滚动降维：
    - 当前节点之和其子节点和子节点的子节点有关，不用dp数组
    - return curMax = max(maxLeft + maxRight, cur.val + preLeft + preRight), preMax = maxLeft + maxRight
- 讲解：
    
    <aside>
    💡 **这道题目算是树形dp的入门题目，因为是在树上进行状态转移，我们在讲解二叉树的时候说过递归三部曲，那么下面我以递归三部曲为框架，其中融合动规五部曲的内容来进行讲解**。
    
    </aside>