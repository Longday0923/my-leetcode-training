# Day13 - 栈与队列 - 滑动窗口最大值, 前 K 个高频元素

## 1. ✅ leetcode ****239. 滑动窗口最大值「[讲解](https://programmercarl.com/0239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.html)」**

- Initial Idea:
    - 做过复习一下思想
    - 滑窗可用队列维护，再维护一个辅助的单调队列/栈来记录当前最大元素和最大元素出队后的最大元素，适合用双端队列实现。
- bugs：
    - nums[i]不是nums[k]
    - 想当然直接max_q.popleft()实现单调，自己试的testcase也没发现。
        - 仔细想清楚，单调队列是从大到小。之和最左边最大元素比，中间较小元素就漏掉了。应该是从右面开始比。
        - testcase想不到的话也应该多随便试几个，指不定就碰到没想到的情况。
- 看讲解：
    - 思路没问题，因为数组和滑窗给了，所以可以省一个滑窗的deque
    - 还可以用单独定义一个单调队列MyQueue，代码可读性强一点。但是代码量大了不少，我还是觉得短的好。
    - 其实第一个滑窗进队和后续滑动还是可以写到一起，需要在pop和res.append加上i和k的比较。时间上显著慢了一点。还是原来的好。

## 2. leetcode ****347. 前 K 个高频元素「[讲解](https://programmercarl.com/0347.%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0.html)」**

- 瞟了一眼讲解发现是小顶堆大顶堆，先复习一下概念了
- 堆：完全二叉树，父节点小于等于/大于等于儿子节点
    - 内部不是完全排序，但可logK时间维护最大或最小
    - push操作：在堆底（数组最后）插入，然后不断上浮（和父亲节点互换位置）至合适的位置
    - pop操作：弹出堆顶元素，把堆底元素放到堆顶，然后不断下沉。
    - push和pop的平均时间复杂度都是O(logk)，k是堆内元素个数。
- python中堆的使用：
    - import heapq
    - heapq.pop(list, int or tuple) / push() / pushpop() / heapify() / heapreplace()等于poppush()
    - 输入元组的第一个为排序的key
    - 小顶堆
    - 可以用来KNN，KMeans算法