# Day24 - 回溯 - 组合, 组合综合, 电话号码的字母组合

## 理论基础「[讲解](https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)」

<aside>
💡 一切回溯问题都可以抽象为树形结构

</aside>

```python
def backtracking(*args): -> None
```

- 回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。
- 回溯：先序遍历 + 进递归处理 & 出递归撤销

## 1.✅****77. 组合「[讲解](https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html#%E5%9B%9E%E6%BA%AF%E6%B3%95%E4%B8%89%E9%83%A8%E6%9B%B2)」**

- Initial Idea:
    - 给出函数的输入参数为：在1～n中选k个组合
    - 希望可以直接利用给出函数递归：
        - 后序遍历：在给定组合第一个数m时先得到所有从m+1到n中的k-1个数的组合，再补上m，再返回。这样每次递归内部只需要产生(n-m, k-1)的组合，然后前面补m，再给每个数加上m即可。
        - 返回值类型：list(list(subCombine))，因为当前递归内每个m对应会得到下层递归传回的一个list，然后本层不同m要合并称为一个list(list)
        - 终止条件：当k==0 or n == k时直接返回。
        - 剪枝：后序遍历保证取过m后，下层递归有效，即至少有k-1个数。需要计算一下迭代区间
        - 难点：因为要求组合从1开始，range左闭右开，所以要计算好边界。
- 看讲解后：
    - 发现我这个其实不算是backtracking，回溯应该是自动push/pop，只用一个常数空间储存当前状态。状态合规时输出or加入res。
    - 这是一个先序遍历的描述：
        - 终止条件只有len(path)==k加入res即可，因为backtracking内的循环应当可以自动排除不够长的path
            - 设计递归内部循环从startId到剪枝后的右边界。每次startId至少+1，当startId已经越过右边界的时候，本层循环就不会被执行。相当于这一分枝的遍历就结束了，直接返回上一层递归，就不会出现不合法的结果了。
        - 返回值可以为None。因为是对一个global的对象持续修改
        - 递归内部循环当前所有可取的m(也就是上面的剪枝操作)，然后先push(m)，带着进入下层递归，返回后出本层递归前再pop(m)

## 2.✅****216.组合总和III「[讲解](https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html)」**

- 仿照回溯的模版，先写终止条件，再写本层递归内部
- 看模版的时候注意到，本层递归的状态（尤其是这种组合问题）是在一进入递归就做好了的。所以进来先判断是否已经找到目标，找到直接返回。
    - 然后在递归主题内，循坏的是下一层循环。所以先push进去的是下一层的初始状态，是本层递归的传入参数。根据不同的下层初始状态，要给下层的下层初始传不同的值。
- 看讲解后：
    - for i in startNum~9还可以再剪枝，和组合问题相同，再减掉k-len(nums)的一些，保留足量给之后的数字。

## 3.✅****17.电话号码的字母组合「[讲解](https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html#%E6%95%B0%E5%AD%97%E5%92%8C%E5%AD%97%E6%AF%8D%E5%A6%82%E4%BD%95%E6%98%A0%E5%B0%84)」**

- 主要的经验点是，截止条件加一个return，本层递归就不需要再添加特别的判定条件了，如果在截止前一直不回错误的话。
- backtracking的递归，可以把递归对象直接写成s + c的形式，这样就隐含了push & pop的行为。