# Day18 - 二叉树 - 找树左下角的值, 路径总和, 路径总和ii, 从中序与后序遍历序列构造二叉树, 从前序与中序遍历序列构造二叉树

## 1.✅513. 找树左下角的值「[讲解](https://programmercarl.com/0513.%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC)」

- Initial Idea:
    - 看准定义：最底层最左边的值。最底层天然层序遍历。每次循环保留当层第一个值即可。
- 看讲解：
    - 也是推荐层序遍历。先序的深搜需要记录每次找到叶子节点的深度，这样其实挺麻烦的。
    - 看了一个leetcode里面的题解：每次先入队右子节点，再入队左子节点。这样最后一个节点就是最底层最左节点。这样确实更快一些。

## 2.✅112. 路径总和「[讲解](https://programmercarl.com/0112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.html)」

- Initial Idea:
    - 一开始想尝试写“隐形递归”的写法，也就是在传参中加上curSum + left.val的操作，但发现这样返回值不好设计。无法区分已经发现True，回溯和完全False……诶不对好像可以只用True和False，因为完全False只在最后判断即可。
    - 一开始写了一个加超了就会剪枝的逻辑，发现val和target都可以是负的
- 看讲解后：
    - 每次都要尝试去直接用给出的函数递归，而非自己再设内部的函数。
    - 这题只使用给出函数的原因有以下几点：
        - not root的情况可以融合进去，即若进到某个None node还没return，也就是这条路已经不可能和为target了
        - 原本的参数targetSum可以用减的方式运算，最后等于node.val或等于0来判断。
        - 这样也不用特意判断left和right是否None，就可以写在一句话里，recur(left) or recur(right)

## 3.✅****113. 路径总和ii****

- Initial idea:
    - 这里倾向于加上多个传递参数的形式，可以让递归内部代码减少
    - bug：如果设sel.path, 会导致res内部其实存的是path的对象，最后都会被清空。所以确实应该使用参数传递来保证实参。
- 看讲解后：
    - 思考和上一题的区别，什么时候有返回值，什么时候没有？
        - 如果需要全集搜索，且不需要特殊处理某一情况，则不用返回值
        - 如果像上题，只需找到一个符合的情况，然后迅速结束；就需要使用不同的返回值来快速跳出递归。
        - 文章还提到了也需要全局搜索，但返回值需要特殊处理的情况，那么也需要设计返回值。

## 4.✅****106. 从中序与后序遍历序列构造二叉树****

- 之前写过前序和中序，类似，复习一下。
- 递归三步曲：
    - 传参：肯定要有left & right，只是不知道需要两序都有还是一个。最后发现两个都有比较好写。
    - 返回值：直接返回node / None
    - 终止条件：左右指针越过时，返回None
    - 递归内部：需要分别找到中序和后序对应子树的边界，然后即可继续。
    - 记得之前看到过，中序可以设一个hash来找对应位置。

## 5.✅****105.从前序与中序遍历序列构造二叉树****

- 写过，直接秒

<aside>
💡 前序+后序不能唯一确定一颗二叉树

</aside>

- 看讲解
    - leetcode官方讲解和我的写法类似，卡哥攻略中有直接使用原本函数的写法，思路都一样，学习一下：
        - 使用原本的函数，传参就是两个数组，返回node
        - 在中序中找到根节点，用的是python list的自带方法：list.index(value)
        - 经测试，这种写法在python中会慢很多。猜测可能是因为传递/切分list较慢，或者是list.index较慢。空间使用也会大很多，是因为传递数组的递归导致的吧。