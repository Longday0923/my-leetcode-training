# Day53 - 动态规划 - 编辑距离, 回文子串, 最长回文子序列

## 1.✅**72. 编辑距离「[讲解](https://programmercarl.com/0072.%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)」**

- Initial Idea:
    - dp数组代表word1以i结尾，word2以j结尾，最少的变换步数。
    - 递推公式：
        - 若1i == 2j, dp[i][j] == dp[i - 1][j - 1]
        - 若不等，这里一开始没写对。
- 讲解：
    - 若不等，题目描述可有3种变换方法：
        - 删，dp[i - 1][j] + 1：word1删掉当前第i个字符1步 + 前i-1与j匹配的最少步数
        - 增，dp[i][j - 1] + 1：word1到i与word2前j-1个字符匹配 + 增加word2的第j个字符
        - 换，dp[i - 1][j - 1] + 1：word1更换最后一个字符为word2的第j个字符 + 前 i -  1与前j - 1的匹配情况。
    - 初始化：
        - 还是(len + 1) * (len + 1)
        - 第一行第一列如何初始化：其含义是其中一个串为空的时候的编辑距离，那么自然等于另一个串的长度，所以for i in range(len + 1): dp[i][0] = i
    - 遍历方向：都从头开始即可

## 2.✅**647. 回文子串「[讲解](https://programmercarl.com/0647.%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.html#%E6%80%9D%E8%B7%AF)」**

- Initial Idea:
    - 这题做过，印象不深，复习一下。
    - dp[i][j]: 从i到j是否为回文串
    - 递推公式：dp[i][j] = dp[i + 1][j - 1] and s[i] == s[j]
    - 初始化和遍历方向很关键：
        - 初始化：所有的dp[i][i] = True, dp[i][i + 1] = True if s[i] = s[i + 1] else False
        - 遍历方向：从上述每个初始化点出发，不断向两边延展，碰到不相等即可跳出。
    - 本体要求回文子串数量，初始化为0，True赋值为1，最后返回sum即可。
- 看讲解：
    - 递推公式在dp数组内的行为，最好形象的想一下，有助于检查遍历方向的正确性。
    - 回文串的递推公式依赖于其左下角元素，同时i≤j，所以dp数组需要从下到上，从左到右遍历；以及只会填充右上半部分。可以不用像我这样讨巧的初始化和遍历，进而写进一段代码中。

## 3.✅**516.最长回文子序列「[讲解](https://programmercarl.com/0516.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97.html#%E6%80%9D%E8%B7%AF)」**

- Initial Idea:
    - 这题过于去照搬上一题的想法了，导致一直没写对。
- 最后一题，绷不住了，看讲解：
    - 首先，上一题没注意对于遍历顺序的讲解是非常错误的。从回文串的递推公式看到它的遍历方向，这样就不用在循环内针对不同情况设很多if else，借助循环方向即可直接排除不合法的ij pair。
    - 第二，因为是子序列，不要求连续。若s[i] == s[j]相同。
        - 若不等，关键在于取什么。这时应该取max(dp[i][j - 1])(dp[i - 1][j])
    - 初始化：全零，长度为0.