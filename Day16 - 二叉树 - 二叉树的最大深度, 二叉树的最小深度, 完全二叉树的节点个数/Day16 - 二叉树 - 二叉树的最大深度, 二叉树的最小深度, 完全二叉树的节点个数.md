# Day16 - 二叉树 - 二叉树的最大深度, 二叉树的最小深度, 完全二叉树的节点个数

## 1. ✅ ****104. 二叉树的最大深度「[讲解](https://www.notion.so/Day16-8d8d32ee72914f678ae66f1826fe13ed?pvs=21)」**

- Initial Idea:
    - 迭代法：层序遍历，带for range(len(layer那种，找到最后一层即可
    - 递归法：dfs先序遍历
        - if not node: compare max depth, return
        - 进递归curD++, 出递归curD—
- 看讲解后：
    - 递归要按照三步走思考：传参和返回值，终止条件，递归内逻辑
    - 先序遍历没什么问题，需要多传一个参数
    - 可以使用后序，思路是先计算两个子树的深度，本节点取max子树深度+1，这样只需一个传参
    - 实际测试：后序代码简单，但是性能最慢

## 2. ✅ ****111.二叉树的最小深度「[讲解](https://programmercarl.com/0111.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6.html#%E9%80%92%E5%BD%92%E6%B3%95)」**

- Initial Idea:
    - dfs应该都要回溯，因为不知道搜到的是不是最小。
    - bfs层序从上往下，不会漏掉，可以early stop.

## 3. ✅ ****222.完全二叉树的节点个数「[讲解](https://programmercarl.com/0222.%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0.html#%E6%99%AE%E9%80%9A%E4%BA%8C%E5%8F%89%E6%A0%91)」**

- Initial Idea:
    - 层序遍历，查到某一个缺子节点的node，通过计算返回总结点个数，这样少遍历了最后一部分。
- 看讲解后：
    - 一开始没看懂为什么dfs可以小于O(n)
    - 仔细看后发现，用到的是完全二叉树的一个特性：若最左子树不等于最右子树深度，则不是完全二叉树，中间的都不用看。
        - 利用这条性质，顺着不是完全二叉树的子树，继续递归进去，直到某一深度时两子树都是完全二叉树。
        - 递归三部曲：
            - 传参：node，返回值：node为根的子树节点个数（2**子树层数 - 1）
            - 终止条件：最左最右子树遍历深度相同，此时子树为完全二叉树，节点个数可以直接计算
            - 递归操作：后序，节点和等于左右子树节点和+1
            - 时间：O(logN * logN) 假设仅差一点成为满二叉树，则需要logN的最右，每次查一遍logN的最左。空间O(logN)递归深度logN
        - 递归传参只有node的好处：可以直接用给的函数递归，所以尽量不加新参数和新全局变量