# Day22 - 二叉树 - 二叉搜索树的最近公共祖先, 二叉搜索树中的插入操作, 删除二叉搜索树中的节点

## 1.✅235. 二叉搜索树的最近公共祖先「[讲解](https://programmercarl.com/0235.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html#%E8%BF%AD%E4%BB%A3%E6%B3%95)」

- Initial Idea:
    - 在最近公共祖先的基础上做一些递归剪枝：
        - 比p小了就不往左找了，比q大了就不往右找了
- 看讲解后：
    - 可以直接自顶向下地找，二叉搜索树就是天然自顶向下的搜索结构
    - 找到的某个node值在[p.val, q.val]内，就是他们的公共祖先。
    - 从上往下找，找到的第一个在区间内的点，肯定是两个点的祖先。这时继续向下找两个点都是能找到的。
    - 如果再往下找，就会错过；一旦进入了某一个子节点，就会错过另一个。因为子节点都是大于或小于这一节点的点。
    - 可以直接使用迭代的方法，自顶向下找一条路径即可，找到第一个符合要求的node直接返回。

## 2.✅****701.二叉搜索树中的插入操作「[讲解](https://programmercarl.com/0701.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.html#%E9%80%92%E5%BD%92)」**

- 大致想了一下，插入的节点一定可以放在叶子节点处。
    - 直接迭代找到符合要求的叶子节点，插在其左or右即可。
    - 需要设一个变量存pre。
- 看讲解：
    - 也是同样思路，不用重构二叉树
    - 但我记得可以用旋转的方式将节点插在上面。搜了一下OI Wiki，和平衡二叉搜索树有关，之后再细看「[树的左旋右旋](https://oi-wiki.org/ds/bst/)」

## 3.✅****450.删除二叉搜索树中的节点「[讲解](https://programmercarl.com/0450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html)」**

- Initial Idea:
    - 首先搞懂正常情况删一个节点如何返回一个合法的BST:
        - 节点左子树最大点为左子树右下角，只要把右子树最小点（右子树的根）接在左子树右下角的右孩子即可。
        - 找到node后，把删除node写成一个单独的函数
        - 外面只要用迭代在BST中找到node即可。
        - 函数参数：targetNode, preNode, isLeft。这样才能删掉更新后赋值给上一个。
    - 再考虑一些边界情况：
        - 如果根节点是key：设一个dummyHead指向root。
        - 如果根节点为空：直接返回None
- 看讲解后：思路是相通的，但是关于删掉一个节点的函数设计，可以优化。
    - 既然把功能切分成两部分，那么至少有一部分要尽可能简单。
    - 可以把迭代在BST中找到targetNode简化，除了把root的case单独拿出来，其他都不要再多写。
    - 删除函数也简化，传入node，返回代替他的新节点。
    - 那么关键代码就在于，在迭代找target过程中，不是判断node，而是判断left和right。如果匹配直接修改left和right。这样就保证了和pre的连接。
        - 注意这里因为排除了root的情况，所以在每次迭代内先判断左右，再迭代到下一个node，否则就一直迭代了。
    - 总结经验是，可以注意递归或者迭代框架，做适当的修改，例如：进入left or right前是否加is not None的判断，或者不是判断当前node而是提前判断left & right，只要不改变遍历顺序，其他可以灵活机动。