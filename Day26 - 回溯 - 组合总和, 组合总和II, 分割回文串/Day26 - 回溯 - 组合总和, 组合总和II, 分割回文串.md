# Day25 - 回溯 - 组合总和, 组合总和II, 分割回文串

## 1. ✅****39.组合总和「[讲解](https://programmercarl.com/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html#%E5%9B%9E%E6%BA%AF%E4%B8%89%E9%83%A8%E6%9B%B2)」**

- 有别于之前的组合总和，这里数字可以重复使用
- 递归下层backtracking的时候，我喜欢使用隐式的递归，即写在参数传递里面
- 重复使用代表两个条件的变化：
    - 递归深度没有限制（横向循环也没有长度可以剪枝）
    - 下层递归的start应当包含当前层的数字
- 如何剪枝：
    - 求和已经超过target的时候应当剪枝，所以我设计降序的sort。这样当前超过target的时候，下一个迭代对象就只会取到更小的数。
- bugs：
    - startId不是本层的starId，而是和横向循环id相关的数字！再次犯错了！要记牢。

## 2.✅****40.组合总和II「[讲解](https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html)」**

- 区别在于：candidates内有重复的，所以结果集内会有重复的（单个结果内可以重复使用数字）
    - 解决方案：每次横向循环，先用，再跳过用过的。
    - bug：注意审题，不可以直接把candidates变成set，最后结果集是list的集合，所以也不能直接取set。也不是再找到的时候去判断，而是在回溯的过程中跳过。
- 看讲解后：
    - “先用，再跳过用过的”有两种写法：
        - 在横向循环内，先执行一次backtracking的递归，然后在后面直接while跳过重复的本层节点
        - 在横向循环内，还是写在递归前，但是加上i > startId的限制，这样就保证了第一个的保留，不会直接在纵向上也把相同的数字跳过了。（实测内存占用小+可读性强）

## 3.✅****131.分割回文串「[讲解](https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html#%E5%9B%9E%E6%BA%AF%E4%B8%89%E9%83%A8%E6%9B%B2)」**

- 关键在于如何构建每层的横向递归：
    - 这里的横向递归不像前面的题，从一个集合中迭代的取。而是以某个startId为起始的不同长短的子串。想好这层就可以了。
- 看讲解：
    
    <aside>
    💡 **其实切割问题类似组合问题**
    
    </aside>
    
    - 练习分析回溯法的时间复杂度：
        - 回溯法相当于看总共有多少排列组合，然后看每个的构造时间
        - 这题相当于任意分割长度为n的字符串，插板法→2^(n-1)种分类，每个的构造时间为O(n)当字符串字母全都相同的时候，递归n次才能找到。所以时间复杂度O(n * 2^n)
        - 空间复杂度？
- 使用回溯算法使用时间较慢，看leetcode的最快写法是动态规划。dp[j]是[:j+1]的回文分割方法，所以后面每次加一个字母，只需要遍历一遍后缀，加到相应前缀dp[j]上即可。学到动态规划再回来仔细写一下。

## [回溯法时间复杂度计算](https://zhuanlan.zhihu.com/p/448969860)