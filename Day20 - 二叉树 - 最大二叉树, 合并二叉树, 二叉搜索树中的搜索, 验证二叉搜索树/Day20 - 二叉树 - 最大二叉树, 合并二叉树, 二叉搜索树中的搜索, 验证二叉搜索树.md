# Day20 - 二叉树 - 最大二叉树, 合并二叉树, 二叉搜索树中的搜索, 验证二叉搜索树

## 1.✅****654.最大二叉树「[讲解](https://programmercarl.com/0654.%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html)」**

- Initial Idea:
    - 两序构建二叉树的简化版
- 看讲解后：
    - 一样可以使用数组下标，时空应该都会优化一些，但需要单独设函数
    - 实际测试并没有优化太多，猜测应该是max的搜索本身已经很慢了。

## 2.✅****617.合并二叉树「[讲解](https://programmercarl.com/0617.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91.html)」**

- Initial Idea:
    - 越来越适应递归三步曲的思路，先看给出的函数，可以通过参数获得一些启发。
    - 给出的参数是两个根，应该返回合成后的根。
    - 所以先判断是否root都合法，如果有不合法直接返回。
    - 如果都合法，就把当前val加和， 然后左右子节点直接递归即可。
- 看讲解后：
    - 我在递归内多写了一个not node1 and not node2的判断，其实没必要。删掉之后快了一些。
    - 还可以通过改动node1的方式，节省时间空间（显著节省空间）。

## 3.✅****700.二叉搜索树中的搜索「[讲解](https://programmercarl.com/0700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.html)」**

- Initial Idea:
    - 递归和迭代都练一下：
        - 递归就没有序了，因为二叉搜索的路径是一定的。
        - 迭代使用的模仿层序，一开始忘记二叉搜索的特性；加上之后也没有显著变快。
        - 递归和迭代的时间复杂都是O(logN)，递归的空间也是O(logN)，迭代的空间是O(1)，因为队列里每层只会有一个点。
        - 那可以改为普通循环？是的，相当于每次给root重新赋值即可。时间O(logN)空间O(1).
- 看讲解后：
    - 因为搜索二叉树有序，所以不需要回溯，自然也不需要辅助栈或者队列。

## 4.✅****98.验证二叉搜索树「[讲解](https://programmercarl.com/0098.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html)」**

- Initial Idea:
    - 一开始看到了提示，应该使用中序遍历。直觉需要设一个preVal，但是没想好怎么设。
    - 设计了一个简单的递归，只判断每个node左右子树是否合法，以及left.val < node.val < right.val。这样并没有完全排序！
    - 再写一下中序遍历：设一个global的preVal，如果使用传参的话，上层递归的preVal不会改变。
    - 中序遍历，print(node) 是按照从小到大的顺序，所以递归node的语句修改preVal的值。
    - 设计剪枝，一旦碰到不合规的点直接return False，全都合规才return True。
- 看讲解：
    - 思想相同