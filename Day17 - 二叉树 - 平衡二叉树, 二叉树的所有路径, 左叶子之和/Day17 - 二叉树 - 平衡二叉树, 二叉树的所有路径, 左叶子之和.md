# Day17 - 二叉树 - 平衡二叉树, 二叉树的所有路径, 左叶子之和

## 1. ✅ 110.平衡二叉树「[讲解](https://programmercarl.com/0110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html)」

- Initial Idea:
    - 一开始设想为层序，找最小层高和最大层高，看差值。
    - 发现左右子树高度相差一并不是最小层高的地方，改为了缺少一个子节点的节点。
    - 缺少一个子节点并不代表那里的树高就会断掉，还是改回最小层高和最大层高的差≤1.
    - 一直在挂一个1,null,2,null,3的testcase，一开始没想明白是一个什么树，后来想通是最右侧的单边树。这样我的算法中计算最小层高的（同时没有左右子节点）判定条件只会在最末位才会触发。
    - 应该从一开始就严格按照定义：每一个节点左右子树高度差≤1。
    - 自己实现了递归的后序遍历，还是先求左右子树高度，如果已经差≥1，直接返回-1；否则返回子树高度。这里加一个-1的赋值是为了和0值以及正的高度区分开。一开始想用return False来实现剪枝，但因为也要return 高度，需要统一返回值的类型。
- 看讲解后：
    - 方法是对的，但是思路不清晰：
        - 求高度只能用后序遍历，求深度才可以用先序或者层序。
        - 高度：节点到叶子；深度：节点到根

## 2. ✅ ****257. 二叉树的所有路径「[讲解](https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html)」**

- Initial Idea
    - 路径 = 先序遍历，回溯 = 递归时候加入push&pop
    - 一开始直接默写先序的终止条件，发现不对，因为递归结束时应当把当前路径放入res
    - 所以改为判定node，然后在node没有左右子节点的时候作为终止条件。
- 看讲解
    - 我的写法是把res和list的path设为全局变量，这样递归时候参数只有node，不容易出错；终止时return “→”.join(path)即可
    - 讲解中还可以将path变为字符串，作为参数传递，每次传递path + “→”，这样本层递归的path就只包含前面的部分，就不用写push & pop了
    - 不过我个人喜欢第一种写法，push & pop更明显体现出回溯的操作。

## 3. ✅ ****404.左叶子之和「[讲解](https://programmercarl.com/0404.%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C.html)」**

- Initial Idea
    - 因为只找最深的叶子节点，可以使用先序遍历
    - 递归参数：node, isLeft，返回值：None
    - 中止条件：找到叶子节点，若是左叶子加到res里，否则直接return
    - 递归逻辑：同样是在找到左叶子的时候加到res里而非not node时候操作，所以递归时需要判断是否node.left/right. 同时别忘记传isLeft的判定。
- 看讲解后
    - 卡哥还是推荐只传node，通过后序设计返回值加和得出最终结果。我感觉这里先序的搜索思想更直接一些。