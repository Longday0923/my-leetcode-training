# Day36 - 贪心 - 无重叠区间, 划分字母区间, 合并区间

## 1.✅****435. 无重叠区间「[讲解](https://programmercarl.com/0435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.html#%E6%80%9D%E8%B7%AF)」**

- 重叠区间与无重叠区间，我现在的套路是，按照“内侧”排序。
- 这里有一个python超时的bug，如果直接使用for i & remove(a[i])，下标i会越界；如果使用for element in list[:]的切片复制 + remove(element) ，会超时。猜测remove(element)是需要搜索的。
    - 比较好的写法是从后向前删除，for i in range(len - 1, -1, -1): list.pop(i)。这样速度快，且不会越界。
- 看讲解：
    - 找到最多的无重叠区间，可以比作会议室使用，贪心的办法，肯定要先安排早结束的会议。所以是按照右边界排序，而非左边界。

## 2.✅****763.划分字母区间「[讲解](https://programmercarl.com/0763.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4.html#%E6%80%9D%E8%B7%AF)」**

- Initial Idea:
    - 一开始直接延续之前重叠区间的套路，如果找不分割数量找的是“内侧”边界，那么找最大重叠/包含，也是维护一个内侧边界，同时需要记录一个外侧起始点。
    - 先用dic记录每个字母的start & end，再执行上面的迭代。
- 看讲解后：
    - 因为不能改变顺序的字符串天然保证左边界升序，所以第一遍迭代只要记录每个字母最后出现的位置即可。
    - 第二遍循环思想相同。
- coding细节：
    - 我的写法是先把第一个左右区间init，然后每次碰到区间结尾，将前一个区间的长度append到res中。这样最后一个需要再append一下。
    - 本题因为start和end肯定是当前字母，所以每次迭代到一个字母，可以先更新end，如果已经在end上，更新出来的end就是自己。这时把当前的start→end加入res。即可保证init(0,0)和最后一段都可自动加入。

<aside>
💡 for循环有时循环element好用，有时循环idx好用。善用enumerate，两者同时得到。

</aside>

## 3.✅****56. 合并区间「[讲解](https://programmercarl.com/0056.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4.html#%E6%80%9D%E8%B7%AF)」**

- 思路相同，实际更简单。可以任选左or右边界排序，第二次遍历时注意两边都要维护即可。
- 看讲解后：
    - 这里可以遇到一个新区间，先append到res中；遇到重叠区间，更新res中的边界即可。这样就把首尾包含到了结果中，不用在循环外单独处理。