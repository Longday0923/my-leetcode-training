# Day43 - 动态规划 - 一和零, 完全背包理论基础, 零钱兑换II

## 1.✅**474.一和零「[讲解](https://programmercarl.com/0474.%E4%B8%80%E5%92%8C%E9%9B%B6.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)」**

- Initial Idea:
    - 每个s in strs是唯一的
    - 思考什么可以作为01背包的容量：0和1的数量
    - 最终要求的是最长的子集
    - 降维后的dp数组为：dp[i][j]表示≤i个0和j个1的最长子集。
    - 递推公式：dp[i][j] = max(dp[i][j], dp[i - count(0)][j - count(1)] + 1)
    - 初始化：(m + 1) * (n + 1)的全零数组
    - 遍历方向：降维后从后往前遍历：i in [m, count(0)], j in [n, count(1)]
- 题解里有更快的解法，看起来是用回溯搜的，做了优化。之后有空再看。

## 完全背包理论基础

- 之前其实凑巧写出来过，就是滚动数组的情况下，从左向右更新了。这时候就会在已经使用了第i件商品的情况下继续使用第i件商品。
- 那么相比01背包，完全背包的区别就在于，更新基于的区域不只是左上方，而是左边和上方。左侧同行先更新，右侧更新时可以基于左侧同行。

```python
def completeBagProblem(weight, value, n):
		dp = [0] * (n + 1)
		for i in range(len(weight):
				for j in range(weight[i], n + 1):
						dp[j] = max(dp[j], dp[i - weight[i]] + value(i))
		return dp[-1]
```

## 2.✅**518.零钱兑换II「[讲解](https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)」**

- 完全背包的练习，注意结果要求返回的是组合数，所以不能使用bitset。
- 注意完全背包的写法和01背包几乎相同，只是内层对容量的循环是从头开始的。
    - 我的一个错误思路：外层循环总的可能个数，内层循环不同重量。这又是回溯/枚举的思路了！

<aside>
💡 在求装满背包有几种方案的时候，认清遍历顺序是非常关键的。

**如果求组合数就是外层for循环遍历物品，内层for遍历背包**。

**如果求排列数就是外层for遍历背包，内层for循环遍历物品**。

</aside>