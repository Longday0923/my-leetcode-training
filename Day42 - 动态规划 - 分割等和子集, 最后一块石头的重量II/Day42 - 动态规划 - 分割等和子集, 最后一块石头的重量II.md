# Day42 - 动态规划 - 分割等和子集, 最后一块石头的重量II

## 1.✅416. 分割等和子集「[讲解](https://programmercarl.com/0416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.html)」

- Initial Idea:
    - 一开始还是自己养成的dp旧思路，只会一次往里面加一个数。维护一个list，里面保存当前所有可能的子集之差。加到最后一个数的时候，如果有0，则成功。
    - 每次迭代到一个新的数，需要新建一个set来保存本轮所有可能的子集之差。
    - 对于上一轮产生的每个diff，需要往内add( diff + num, abs(diff - num))
    - 设共m个数，和为n，粗略感觉是(2^m - 1) ~= O(2^m)，空间(2^(m - 1)) = O(2^m)。
    - 从复杂度上看，还是在做回溯，相当于是暴力法。
- 看讲解：
    - 可以先剪枝和为奇数的情况。
    - 这是一道典型的01背包问题！备选集内每个对象的值不一定，只能选一次，求一个目标和。
    - 关键点是要想到，不是在求整体的和为零，而是去求一部分和==sum/2
    - 01背包使用2维dp，分别是第i个元素，和为j
        - 第一种写法是，dp[j]保存的是，截止第i个元素，容量为j时最大存多少。相当于是≤j的最大和。（这里跳过2维，直接设计滚动数组）
        - 递推公式：dp[j] = dp[j] if nums[i] > j else max(dp[j], dp[j - nums[i]] + nums[i])
        - 初始化dp[0] = 0 空集
    - 因为我们最终只需要知道对于某个容量能否装满，所以可以对数组进行简化，只存True / False。
        - dp[j] = True if 可以和为j else False
        - dp[j] = dp[j] if nums[i] > j else dp[j] or dp[j - nums[i]]
            - 理解：若容量-num的和可以得到，那么容量也可以得到。
    - 初始化dp[0] = True 空集
- 神奇的位运算
    - 初始化 dp = 1
    - 递推公式 dp |= dp << nums[i]
    - 结果：dp >> sum / 2 & 1 == 1
    - 理解：dp二进制的第j位表示了容量为j是否可以获得，最后返回第sum / 2位是否为1即可。递推公式的或运算保证了一次运算直接得到有nums[i]时所有可以获得的数。
    - 太巧妙了。
    
    ```python
    def canPartition(self, nums: List[int]) -> bool:
            sum_ = sum(nums)
            if sum_ & 1: return False
            half, dp = sum_ // 2, 1
            for num in nums: dp |= dp << num        
            return dp >> half & 1 == 1
    ```
    

<aside>
💡 01背包问题特征：从备选集中选子集，求和。同时每个对象只能选一次。
使用方法：外层循环是每个备选集中元素的脚标，内层一定是一个连续的值，最终的目标是一个累积的值而不是一个固定值。

</aside>

## 2.✅**1049.最后一块石头的重量II「[讲解](https://programmercarl.com/1049.%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)」**

- 一开始纠结了半天，是否和选出子集求和是等价的。关键发现在于，公式完全展开，还是每个石头的重量取正or负然后求和，相当于分成两个子集，看各自求和的差最小是多少。
- 基于上题，用位运算版的动态规划求出所有子集之和的可能性，然后找sum_//2后的最高位，最后返回sum_ - 2* 最高位，即是两个子集的差。也就是第一个子集都取正号，第二个子集都取负号。

## 3.✅**494.目标和「[讲解](https://programmercarl.com/0494.%E7%9B%AE%E6%A0%87%E5%92%8C.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)」**

- 还是去思考如何转化为01背包：(sum(nums) - target) // 2 = 目标容量
- 本体dp存的是达到目标容量的不同子集，所以dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]]
- 细节：
    - 滚动数组实现
    - sum - target若奇数直接返回0
    - dp[0] = 1
- bug:
    - 若sum已经小于target，则肯定不能，直接返回0